在開始之前，還是先宣傳一下自己的新遊戲啦！不知道大家有沒有看我的上一篇文章，三角函數—使用三角函數移動物件，裡面我所遇到的問題不是憑空杜撰，是我在製作「火輪手槍」這個遊戲時所遇到的。我遊戲是用Python寫的，要知道寫一個遊戲像不像真的在遊戲體驗上很重要，尤其Pygame基本上沒有什麼物理引擎，不能像Unity這類的遊戲引擎那麼快速的做出仿真的遊戲效果。所以在物理模擬方面，是我自行研究與開發的，在文章的下面，我也會提供我所開發的GameObject物件，裡面有了遊戲的基本框架，像是我的碰撞檢測，慣性移動等等，都會在下方文章詳談。
大綱：
1. 碰撞檢測
2. 移動—使用積分
3. 程式架構

一、碰撞檢測
碰撞檢測是什麼東西？簡單來講就是分辨「你現在撞到XX了嗎？」，在現實世界這是很自然的事，我怎麼知道我撞到牆了？人沒辦法穿過去嘛！你的觸覺神經感受到狀上去的反作用力，大腦自然就知道你「撞上去了」。基本上碰撞檢測最基礎的應用就是「我被怪物碰到了嗎？」，以小蜜蜂這個遊戲，當玩家發射出子彈後，電腦要怎麼分辨是否「被子彈打到了」，我們遊戲物件在電腦中其實只是一個個座標的數據，程式要如何透過座標、圖形大小、旋轉角度這些資料去判斷一個物體是否「碰到」另一個物體呢？
如果物件是圓形，最簡單的方法就是「兩者的距離是否小於兩者的半徑總和」，這個原理應該不用我詳細講，而如何求出兩者的距離呢？這就要用到畢氏定理啦！

二、慣性移動
	不知道大家有沒有玩過「超級馬力歐」？我是有玩過，個人對它印象很深刻的是它移動的效果，如果有玩過得會知道，當你要煞車的時候，馬力歐還會往前衝一段距離才停下來，這對於操作說實在是不太方便，但也增加了遊戲的挑戰性和真實性，不知道大家有沒有想過這個「慣性」是怎麼做出來的呢？慣性這種東西在數學上寫起來是非常可怕的，畢竟速度是一種時間函數，數學只要扯到時間寫起來就會讓人很想哭… ，但是我們是寫程式呀！程式有迴圈這個玩意，因此要做積分或是各種函數都會很容易。
	首先在此聲明，我所實做的慣性跟物理學上的摩擦力並不「完全相同」，這邊為了遊戲效果並沒有做靜摩擦力、動摩擦力，而是製作類似空氣阻力—速度愈快、阻力愈大的機制，本人也有製作過較符合物理學的慣性系統，但遊戲效果較差，故不採用。

	首先是原理，在每一次的loop速度v會加入一個加速度，這個加速度的大小影響角色移動的快慢，而在每一次增加加速度後，v會被乘上一個介於0到1之間的常數，我們稱為縮小倍率好了，每一次v要加入新的加速度前都會被乘上縮小倍率，舉個例子：當加速度固定是1、縮小倍率是0.5，一開始速度為0，下一個迴圈變成1，下一個迴圈舊的速度1乘上了0.5，加上新的速度，於是速度變成1 + 0.5 = 1.5。再下一個瞬間1 * 0.5，0.5 * 0.5，再加入新的加速度，於是第三個迴圈速度變成1 + 0.5 + 0.25 = 1.75。
	而當角色失去了加速度，每個迴圈仍然會將舊的速度乘上縮小倍率，於是以剛才的例子，1 * 0.5 + 0.5 * 0.5 + 0.25 * 0.5，但是由於加速度是0，所以沒有加入新的1，這時速度就變成0.5 + 0.25 + 0.125 = 0.875，注意到了嗎？速度從剛才的1.75掉到了0.875，減速了。
	剛才複雜的說明其實可以總歸一個簡單的算式：
速度 = 上一次速度 * 縮小倍率 + 加速度
	這樣當角色失去加速度（也就是要停下來），速度就會趨近於0。而這個縮小倍率就是掌控摩擦力大小的關鍵，當縮小倍率越接近1，就會感覺移動起來越「滑」。
那這樣一直加速，難道不會無限變快下去嗎？事實上不會，而且非常快就不會了，該如何算出這個算式的極限呢？
	知道為什麼前面我要特意把每次速度的加法算式寫出來嗎？我們來觀察一下，第一迴圈為1，第二迴圈為1 + 0.5，第三迴圈為 1 + 0.5 + 0.25，第四迴圈為 1 + 0.5 + 0.25 + 0.125，寫到這裡你一定也觀察到了，在等加速度的狀態下，前面的數字都沒有改變，增加的就只有最後面的數字而已，如果將迴圈次數定為t，那每次速度就是增加 0.5^t （0.5的t次方），所以當t越來越大時，增加的速度就會越來越小，到最後幾乎沒有增加，這就是速度的極限啦！

